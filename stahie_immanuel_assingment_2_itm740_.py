# -*- coding: utf-8 -*-
"""Stahie_Immanuel Assingment 2 ITM740 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JKtGjhjr4MG3Oe-CA5tuzJ0jf2z1bm3b
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import torch
from torch.utils.data import Dataset, DataLoader
import torch.nn as nn
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score

# Load and Preprocess Data
data = pd.read_csv('/content/bcancer_data.csv')
X = data.iloc[:, :9]  # Assuming the first 9 columns are features
y = data.iloc[:, 9]   # Assuming the target 'Class' is in the 10th column

# Normalize features
scaler = StandardScaler()
X_normalized = scaler.fit_transform(X)

# Split Data
X_train, X_test, y_train, y_test = train_test_split(X_normalized, y, test_size=0.2, random_state=42)

# Convert to PyTorch tensors
X_train_t = torch.tensor(X_train, dtype=torch.float32)
X_test_t = torch.tensor(X_test, dtype=torch.float32)
y_train_t = torch.tensor(y_train.values, dtype=torch.float32)
y_test_t = torch.tensor(y_test.values, dtype=torch.float32)

# Define PyTorch Dataset and DataLoader
class BreastCancerDataset(Dataset):
    def __init__(self, features, labels):
        self.features = features
        self.labels = labels

    def __len__(self):
        return len(self.labels)

    def __getitem__(self, idx):
        return self.features[idx], self.labels[idx]

train_dataset = BreastCancerDataset(X_train_t, y_train_t)
test_dataset = BreastCancerDataset(X_test_t, y_test_t)

train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)

# Build Neural Network Model
class BreastCancerNN(nn.Module):
    def __init__(self):
        super(BreastCancerNN, self).__init__()
        self.layer1 = nn.Linear(9, 10)  # Assuming 9 input features
        self.relu = nn.ReLU()
        self.output_layer = nn.Linear(10, 1)

    def forward(self, x):
        x = self.layer1(x)
        x = self.relu(x)
        x = self.output_layer(x)
        return x

# Initialize model, loss function, and optimizer
model = BreastCancerNN()
criterion = nn.BCEWithLogitsLoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.1)

# Training
for epoch in range(100):  # Train for 100 epochs
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels.unsqueeze(1))  # Adjust shape of labels to match output
        loss.backward()
        optimizer.step()
    print(f'Epoch {epoch+1}, Loss: {loss.item()}')

# Testing and Evaluation
predictions, actuals = [], []
with torch.no_grad():
    for inputs, labels in test_loader:
        outputs = model(inputs)
        predicted = (torch.sigmoid(outputs) > 0.5).float()  # Using sigmoid to get binary output
        predictions.extend(predicted.view(-1).tolist())
        actuals.extend(labels.tolist())

# Calculate metrics
cm = confusion_matrix(actuals, predictions)
accuracy = accuracy_score(actuals, predictions)
precision = precision_score(actuals, predictions)
recall = recall_score(actuals, predictions)

print(f'Confusion Matrix:\n{cm}')
print(f'Accuracy: {accuracy}')
print(f'Precision: {precision}')
print(f'Recall: {recall}')